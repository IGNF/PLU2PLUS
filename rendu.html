<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Rendu</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>		
		<script type="x-shader/x-vertex" id="vertexShader">
		
			attribute vec3  position2;
			uniform   vec2  resolution;
			uniform   float thickness;
			varying   vec3 v_uv;
			varying   float choixTex;
			void main() {
			gl_Position = projectionMatrix *
							modelViewMatrix *
							vec4(position,1.0);

			vec4 Position2 = projectionMatrix *
							modelViewMatrix *
							vec4(position2,1.0);

			vec2 normal = normalize((gl_Position.xy/gl_Position.w - Position2.xy/Position2.w) * resolution); // * 0.5
			normal = uv.x * uv.y * vec2(-normal.y, normal.x);

			if (length((gl_Position.xyz+Position2.xyz)/2.0)>25.0){
				gl_Position.xy += 25.0*(thickness/length((gl_Position.xyz+Position2.xyz)/2.0)) * gl_Position.w * normal * 2.0 / resolution;
				}
			else {
				gl_Position.xy += thickness * gl_Position.w * normal * 2.0 / resolution;
			}

			if (distance(position, position2) < 3.0){
				choixTex = 1.0;
				
			} else if (distance(position, position2) > 10.0){
				choixTex = 3.0;
			//	v_uv = vec3(2.0*(uv.x-0.5),uv.y,1.)*gl_Position.w;
			}else {
				choixTex = 2.0;
			}

			v_uv = vec3(uv,1.)*gl_Position.w;

			}
				


		</script>
		<script type="x-shader/x-fragment" id="fragmentShader">
			varying vec3  v_uv;
			varying float choixTex;
			uniform sampler2D texture1;
			uniform sampler2D texture2;
			uniform sampler2D texture3;
			//uniform sampler2D paper;
			uniform vec3 color;
			

			void main() {
			vec2 uv = v_uv.xy/v_uv.z;
			vec4 baseColor = texture2D(texture1, (uv+1.)*0.5);
			//vec4 paperColor = texture2D(paper, (uv+1.)*0.5 );

			if (choixTex == 2.0){
				baseColor = texture2D(texture2, (uv+1.)*0.5);   
			} else if (choixTex == 3.0){
				baseColor = texture2D(texture3, (uv+1.)*0.5);   
			}

			if ( baseColor.a < 0.3 ) discard;
				gl_FragColor = baseColor+vec4(color,0.0); //0.0 si on veut la transparence des arÃªtes
			}
		
		</script>

		<input type="file" id="file"></input>
		<div id="container"/>

		<script src="js/three.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/MTLLoader.js"></script>
		<script src="fonctions.js"></script>
		<script src="fonctions_sliders.js"></script>
		<script src="fonctions_load.js"></script>
		<script src="fonctions_gui.js"></script>
		<script src="js/FileSaver.min.js"></script>
		<script src="js/Stuk-jszip-4cbaf0e/dist/jszip.min.js"></script>
		<script src="js/jquery.min.js"></script>
		<script>

		var scene, camera, renderer, gui, params, plane, selection, clock;
		var raycaster = new THREE.Raycaster();
		var offset = new THREE.Vector3();
		var objects = [];
		var positions = [];

		//initialisation des mesh et lines
		var arrayMur = [];
		var arrayToit = [];
		var arrayAretes = [];				
		var arrayQuads = [];				
		var arrayQuadsContexte = [];				
		var arrayBDToit = [];
		var arrayBDMur = [];
		var arrayAretesContexteBati = [];
		var arrayAretesContexteBD = [];
		var arrayBatiMur = [];
		var arrayBatiToit = [];
		var arrayAretesContexte = [];
		var arrayOrtho = [];
		var arrayAretesOrtho = [];
		var arrayArbres = [];
		var arrayAretesArbres = [];
		
		var zip = new JSZip();
		var nbImage = 0;
		var nbArbres = 0;
		var parse;
		var no = 1;
		var newID;
		//var dom = new dat.dom();
		/*var textureLoader = new THREE.TextureLoader();
		var wallMaterial = new THREE.MeshBasicMaterial( {map: null,color: 0xffffff,shading: THREE.SmoothShading} );
					textureLoader.load( "./textures/wall.jpg", function( map ) {
						map.wrapS = THREE.RepeatWrapping;
						map.wrapT = THREE.RepeatWrapping;
						map.anisotropy = 4;
						map.repeat.set( 0.1, 0.1 );
						wallMaterial.side = THREE.DoubleSide;
						wallMaterial.map = map;
						wallMaterial.needsUpdate = true;
		} );*/
			
		loadAll();
			
		

		//gestion du drag&drop pour les arbres
		/*function onDocumentMouseDown (event) {
			// Get mouse position
			var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
			var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

			// Get 3D vector from 3D mouse position using 'unproject' function
			var vector = new THREE.Vector3(mouseX, mouseY, 1);
			vector.unproject(camera);

			// Set the raycaster position
			raycaster.set( camera.position, vector.sub( camera.position ).normalize() );

			// Find all intersected objects
			var intersects = raycaster.intersectObjects(objects);

			if (intersects.length > 0) {
				// Disable the controls
				controls.enabled = false;

				// Set the selection - first intersected object
				selection = intersects[0].object;

				// Calculate the offset
				var intersects = raycaster.intersectObject(plane);
				offset.copy(intersects[0].point).sub(plane.position);
			}
		}


		


		 function onDocumentMouseMove (event) {
			event.preventDefault();

			// Get mouse position
			var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
			var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

			// Get 3D vector from 3D mouse position using 'unproject' function
			var vector = new THREE.Vector3(mouseX, mouseY, 1);
			vector.unproject(camera);

			// Set the raycaster position
			raycaster.set( camera.position, vector.sub( camera.position ).normalize() );

			if (selection) {
				// Check the position where the plane is intersected
				var intersects = raycaster.intersectObject(plane);
				// Reposition the object based on the intersection point with the plane
				selection.position.copy(intersects[0].point.sub(offset));
			} else {
				// Update position of the plane if need
				var intersects = raycaster.intersectObjects(objects);
				if (intersects.length > 0) {
				plane.position.copy(intersects[0].object.position);
				plane.lookAt(camera.position);
				}
			}
		}

		 function onDocumentMouseUp(event) {
			 if (selection){
				 for ( var i = 0; i < positions.length; i++ ) {
					 positions[i] = objects[i].position;
					}
			}
			// Enable the controls
			controls.enabled = true;
			selection = null;
		}*/

				

				
		function init() {
			var couleur_fond = 0xAADFF4;
		
			scene = new THREE.Scene();
			clock = new THREE.Clock();
			var WIDTH = window.innerWidth,
			HEIGHT = window.innerHeight;
			renderer = new THREE.WebGLRenderer({antialias:true, alpha:true, preserveDrawingBuffer: true });
			renderer.setSize(WIDTH, HEIGHT);
			renderer.setClearColor( couleur_fond, 0.5);
			document.body.appendChild(renderer.domElement);
			camera = new THREE.PerspectiveCamera(10, WIDTH / HEIGHT, 10, 100000);
			camera.position.set(-300,425,325);
			camera.up.set(0,0,1);
			scene.add(camera);

			plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(500, 500, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff}));
			plane.visible = false;
			scene.add(plane);
			
			window.addEventListener('resize', function() {		
				var WIDTH = window.innerWidth,
				HEIGHT = window.innerHeight;
				renderer.setSize(WIDTH, HEIGHT);
				camera.aspect = WIDTH / HEIGHT;
				camera.updateProjectionMatrix();
			});

			document.addEventListener('mousemove', this.onDocumentMouseMove, false);
			document.addEventListener('mousedown', this.onDocumentMouseDown, false);
	  		document.addEventListener('mouseup', this.onDocumentMouseUp, false);
			
			//lights
			var light = new THREE.HemisphereLight(0xffffff, 0.8);
			light.position.set(250,100,-100);
			scene.add(light);
			var sphereSize = 1;
			var pointLightHelper = new THREE.HemisphereLightHelper( light, sphereSize );
			//scene.add( pointLightHelper );
			var light2 = new THREE.HemisphereLight(0xffffff, 0.5);
			light2.position.set(-50,80,-20);
			scene.add(light2);
			var ambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light
			scene.add( ambientLight );
			
			//controls
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set( -50, 30, 0 );

		}	
			
		function animate() {
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
			controls.update();
			for (var i in gui.__controllers) {
				gui.__controllers[i].updateDisplay();
			}
			for (var j = 0; j < parse.couches.length; j++){
				changeName(parse.couches[j], params["name"+parse.couches[j].id]);
				changeColor(parse.couches[j], params["colorFill"+parse.couches[j].id]);
				changeColorAretes(parse.couches[j], params["colorStroke"+parse.couches[j].id]);
				changeOpacite(parse.couches[j], params["opaFill"+parse.couches[j].id]);
				changeTypeAretes(parse.couches[j], params["typeStroke"+parse.couches[j].id] );
				if (parse.couches[j].style.parameters.stroke.type === "Sketchy"){
					changeStyleTrait(parse.couches[j], params["uriStroke"+parse.couches[j].id] );
					changeEpaisseur(parse.couches[j], params["widthStroke"+parse.couches[j].id])
				}
				changeTypeSurface (parse.couches[j], params["typeFill"+parse.couches[j].id] );
				if (parse.couches[j].style.parameters.fill.type === "image"){
					changeTexture (parse.couches[j], params["imageFill"+parse.couches[j].id] );
				}
			}

		}
		
		window.addEventListener("keyup", capture);

		</script>
	</body>
</html>